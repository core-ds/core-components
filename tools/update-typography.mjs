import fse from 'fs-extra';
import fs from 'node:fs/promises';
import path from 'node:path';
import postcss from 'postcss';
import resolve from 'resolve';

import { getPackages } from './monorepo.cjs';

/**
 * @returns {import('postcss').Plugin}
 */
function generateTypography({ data }) {
    return {
        postcssPlugin: 'postcss-generate-typography',
        Once: (root, helpers) => {
            // formatting
            root.assign({ raws: { semicolon: false, after: '\n' } });

            root.append(
                helpers.postcss.comment({
                    text: 'THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY',
                    // formatting
                    raws: { left: ' ', right: ' ' },
                }),
            );

            Object.entries(data).forEach(([name, rules]) => {
                const atRule = helpers.postcss.atRule({
                    name: 'define-mixin',
                    params: name,
                    nodes: Object.entries(rules).flatMap(([rawProp, rawValue]) => {
                        const prop = rawProp.replace(/_/, '-').toLocaleLowerCase();
                        const value =
                            typeof rawValue === 'number' && !(prop === 'font-weight')
                                ? `${rawValue}px`
                                : rawValue;
                        const result = [];

                        if (
                            (prop === 'deprecated' && value) ||
                            (prop === 'font-family' && value === 'var(--font-family-system)')
                        ) {
                            return result;
                        }

                        // code formatting
                        const raws = { before: `\n${' '.repeat(4 /* indent size in spaces */)}` };

                        if (prop === 'font-family' && value === 'var(--font-family-styrene)') {
                            result.push(
                                helpers.postcss.decl({
                                    prop: 'font-feature-settings',
                                    value: "'ss01'",
                                    raws,
                                }),
                            );
                        }

                        result.push(helpers.postcss.decl({ prop, value, raws }));

                        return result;
                    }),
                    // formatting
                    raws: {
                        before: '\n\n',
                        between: ' ',
                        afterName: ' ',
                        semicolon: true,
                        after: '\n',
                    },
                });

                root.append(atRule);

                if (rules.deprecated) {
                    atRule.after(
                        helpers.postcss.comment({
                            text: 'deprecated',
                            // formatting
                            raws: { before: ' ', left: ' ', right: ' ' },
                        }),
                    );
                }
            });
        },
    };
}

async function main() {
    const { packages } = getPackages();
    const vars = packages.find(
        ({ packageJson: { name } }) => name === '@alfalab/core-components-vars',
    );
    const typographyData = await fse.readJson(
        resolve.sync('ui-primitives/styles/typography_web.json'),
        { encoding: 'utf8' },
    );
    const result = await postcss(generateTypography({ data: typographyData })).process(
        postcss.root(),
        { from: undefined },
    );

    fs.writeFile(
        path.join(vars.dir, 'src/typography.css'),
        // FIXME stripping redundant line feeds - `raws.before` doesn't have effect for comments
        result.css.replace(/(\})\n+(\/)/g, '$1 $2'),
        { encoding: 'utf8' },
    );
}

await main();
