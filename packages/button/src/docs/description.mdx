## Виды кнопок

```jsx live mobileHeight={475}
render(() => {
    const [disabled, setDisabled] = React.useState(false);

    return (
        <Container>
            <Row align='middle'>
                <Col>
                    <ButtonDesktop disabled={disabled} view='accent'>Accent</ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop disabled={disabled} view='primary'>Primary</ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop disabled={disabled} view='secondary'>Secondary</ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop disabled={disabled} view='tertiary'>Tertiary</ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop disabled={disabled} view='link'>Link</ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop disabled={disabled} view='ghost'>Ghost</ButtonDesktop>
                </Col>
            </Row>
            <Gap size='xl' />
            <Switch
                checked={disabled}
                onChange={() => setDisabled((prevState) => !prevState)}
                label='Недоступна'
            />
        </Container>
    );
});
//MOBILE
render(() => {
    const [disabled, setDisabled] = React.useState(false);

    return (
        <Container>
            <ButtonMobile block={true} disabled={disabled} view='accent'>Accent</ButtonMobile>
                <Gap size='m' />
            <ButtonMobile block={true} disabled={disabled} view='primary'>Primary</ButtonMobile>
                <Gap size='m' />
            <ButtonMobile block={true} disabled={disabled} view='secondary'>Secondary</ButtonMobile>
                <Gap size='m' />
            <ButtonMobile block={true} disabled={disabled} view='tertiary'>Tertiary</ButtonMobile>
                <Gap size='m' />
            <ButtonMobile block={true} disabled={disabled} view='link'>Link</ButtonMobile>
                <Gap size='m' />
            <ButtonMobile block={true} disabled={disabled} view='ghost'>Ghost</ButtonMobile>
            <Gap size='xl' />
            <Switch
                checked={disabled}
                onChange={() => setDisabled((prevState) => !prevState)}
                label='Недоступна'
            />
        </Container>
    );
});
```

## Размеры

Кнопка доступна в размерах XL, L, M, S, XS, XXS.

```jsx live
const SIZES = ['xl', 'l', 'm', 's', 'xs', 'xxs'];

render(
    <Container>
        <Row>
            {SIZES.map((size) => (
                <Col key={size}>
                    <ButtonDesktop size={size} view='primary'>
                        {`${size.toUpperCase()}-size`}
                    </ButtonDesktop>
                </Col>
            ))}
        </Row>
    </Container>,
);
//MOBILE
const SIZES = ['xl', 'l', 'm', 's', 'xs', 'xxs'];

render(
    <Container>
        {SIZES.map((size) => (
        <>
            <ButtonMobile block={true} size={size} view='primary'>
                {`${size.toUpperCase()}-size`}
            </ButtonMobile>
            <Gap size='m' />
        </>
        ))}
    </Container>
);
```

## Ширина

Кнопка адаптируется под длину контента. Для каждого вертикального размера кнопки задан минимальный горизонтальный размер.
С помощью свойства `block` можно заставить кнопку занимать всю ширину контейнера.

```jsx live
<Container>
    <Row>
        <Col>
            <ButtonDesktop>0</ButtonDesktop>
        </Col>
    </Row>
    <Row>
        <Col>
            <ButtonDesktop>Очень длинный лейбл</ButtonDesktop>
        </Col>
    </Row>
    <br />
    <ButtonDesktop block={true} size='m' nowrap={true}>
        Занимает всю ширину контейнера
    </ButtonDesktop>
</Container>
//MOBILE
<Container>
    <Row>
        <Col>
            <ButtonMobile>0</ButtonMobile>
        </Col>
    </Row>
    <Row>
        <Col>
            <ButtonMobile>Очень длинный лейбл</ButtonMobile>
        </Col>
    </Row>
    <br />
    <ButtonMobile block={true} size='m' nowrap={true}>
        Занимает всю ширину контейнера
    </ButtonMobile>
</Container>
```

## Анатомия

С помощью слотов `leftAddons` и `rightAddons` можно кастомизировать кнопку. Например, добавить иконку.
Переданный контент будет отрисован слева или справа от текста кнопки. Если текста нет — будет отрисована квадратная кнопка.

```jsx live
render(() => {
    const [label, setLabel] = React.useState(true);
    const [leftAddons, setLeftAddonsl] = React.useState(false);
    const [rightAddons, setRightAddons] = React.useState(false);

    const handleLabelChange = () => setLabel(!label);
    const handleLeftAddonsChange = () => setLeftAddonsl(!leftAddons);
    const handleRightAddonsChange = () => setRightAddons(!rightAddons);

    return (
        <Container>
            <Row>
                <Col>
                    <ButtonDesktop
                        leftAddons={leftAddons && <StarMIcon />}
                        rightAddons={rightAddons && <StarMIcon />}
                        view='primary'
                    >
                        {label && 'Label'}
                    </ButtonDesktop>
                </Col>
            </Row>

            <Row align='middle'>
                <Switch label={<span>Label</span>} checked={label} onChange={handleLabelChange} />
            </Row>

            <Row align='middle'>
                <Switch
                    label={<span>LeftAddons</span>}
                    checked={leftAddons}
                    onChange={handleLeftAddonsChange}
                />
            </Row>

            <Row align='middle'>
                <Switch
                    label={<span>RightAddons</span>}
                    checked={rightAddons}
                    onChange={handleRightAddonsChange}
                />
            </Row>
        </Container>
    );
});
//MOBILE
render(() => {
    const [label, setLabel] = React.useState(true);
    const [leftAddons, setLeftAddonsl] = React.useState(false);
    const [rightAddons, setRightAddons] = React.useState(false);

    const handleLabelChange = () => setLabel(!label);
    const handleLeftAddonsChange = () => setLeftAddonsl(!leftAddons);
    const handleRightAddonsChange = () => setRightAddons(!rightAddons);

    return (
        <Container>

            <ButtonMobile
                leftAddons={leftAddons && <StarMIcon />}
                rightAddons={rightAddons && <StarMIcon />}
                view='primary'
                block={label}
            >
                {label && 'Label'}
            </ButtonMobile>

            <Row align='middle'>
                <Switch label={<span>Label</span>} checked={label} onChange={handleLabelChange} />
            </Row>

            <Row align='middle'>
                <Switch
                    label={<span>LeftAddons</span>}
                    checked={leftAddons}
                    onChange={handleLeftAddonsChange}
                />
            </Row>

            <Row align='middle'>
                <Switch
                    label={<span>RightAddons</span>}
                    checked={rightAddons}
                    onChange={handleRightAddonsChange}
                />
            </Row>
        </Container>
    );
});
```

## Перенос текста внутри кнопки

С помощью свойства `nowrap` можно запретить перенос текста на новую строку.

```jsx live
render(() => {
    const [checked, setChecked] = React.useState(true);

    const handleChange = () => setChecked(!checked);

    return (
        <Container>
            <div style={{ display: 'flex', width: '180px' }}>
                <ButtonDesktop view='primary' nowrap={checked}>
                    Пример длинного текста
                </ButtonDesktop>
            </div>
            <Row align='middle'>
                <Switch
                    label={<span>Запретить перенос строки</span>}
                    checked={checked}
                    onChange={handleChange}
                />
            </Row>
        </Container>
    );
});
//MOBILE
render(() => {
    const [checked, setChecked] = React.useState(true);

    const handleChange = () => setChecked(!checked);

    return (
        <Container>
            <div style={{ display: 'flex', width: '180px' }}>
                <ButtonMobile view='primary' nowrap={checked}>
                    Пример длинного текста
                </ButtonMobile>
            </div>
            <Row align='middle'>
                <Switch
                    label={<span>Запретить перенос строки</span>}
                    checked={checked}
                    onChange={handleChange}
                />
            </Row>
        </Container>
    );
});
```

## Обработка событий

С помощью свойства `loading` можно отобразить состояние загрузки.
Минимальное время отображения лоадера — 500мс, чтобы при быстрых ответах от сервера кнопка не «моргала».

```jsx live expanded
render(() => {
    const [loading, setLoading] = React.useState({
        primary: false,
        secondary: false,
    });

    const handleClick = (buttonName, timeout) => {
        setLoading({ ...loading, [buttonName]: true });
        setTimeout(() => {
            setLoading({ ...loading, [buttonName]: false });
        }, timeout);
    };

    return (
        <Container>
            <Row align='middle'>
                <Col>
                    <ButtonDesktop
                        view='primary'
                        loading={loading.primary}
                        onClick={() => handleClick('primary', 30)}
                    >
                        Быстрый запрос (30ms)
                    </ButtonDesktop>
                </Col>
                <Col>
                    <ButtonDesktop
                        view='secondary'
                        loading={loading.secondary}
                        onClick={() => handleClick('secondary', 1500)}
                    >
                        Долгий запрос (1500ms)
                    </ButtonDesktop>
                </Col>
            </Row>
        </Container>
    );
});
//MOBILE
render(() => {
    const [loading, setLoading] = React.useState({
        primary: false,
        secondary: false,
    });

    const handleClick = (buttonName, timeout) => {
        setLoading({ ...loading, [buttonName]: true });
        setTimeout(() => {
            setLoading({ ...loading, [buttonName]: false });
        }, timeout);
    };

    return (
        <Container>
            <ButtonMobile
                view='primary'
                loading={loading.primary}
                block={true}
                onClick={() => handleClick('primary', 30)}
            >
                Быстрый запрос (30ms)
            </ButtonMobile>
            <Gap size='m' />
            <ButtonMobile
                view='secondary'
                loading={loading.secondary}
                block={true}
                onClick={() => handleClick('secondary', 1500)}
            >
                Долгий запрос (1500ms)
            </ButtonMobile>
        </Container>
    );
});
```

## Кнопка-ссылка

Любую кнопку можно превратить в ссылку, передав компоненту пропс `href`.

```jsx live
<Container>
    <Row align='middle'>
        <Col>
            <ButtonDesktop view='primary' href='https://alfabank.ru' target='_blank'>
                Кнопка-ссылка
            </ButtonDesktop>
        </Col>
    </Row>
</Container>
//MOBILE
<Container>
    <ButtonMobile block={true} view='primary' href='https://alfabank.ru' target='_blank'>
        Кнопка-ссылка
    </ButtonMobile>
</Container>
```

## Другие кнопки

Если нужна кнопка с одной иконкой, но без подложки, используйте [IconButton](/docs/iconbutton--docs).

Если нужна кнопка с другим цветом фона, используйте [CustomButton](/docs/custombutton--docs).

Если нужна кнопка с выпадающим списком, используйте [PickerButton](/docs/pickerbutton--docs).
