## Размеры

Основным типом инпутов в десктопном вебе являются инпуты размера M с внутренним расположением лейбла. 
Для мобильного веба рекомендуемый размер S с внешним расположением лейбла.

```jsx live
render(() => {
    return (
        <div style={{ width: 320 }}>
            <InputDesktop 
                placeholder='Введите текст' 
                block={true} 
                label='Текст' 
                size='m' />
            <Gap size='m' />
            <InputDesktop 
                placeholder='Введите email' 
                block={true} 
                label='Email' 
                size='m' 
            />
        </div>
    );
});
//MOBILE
render(() => {
    return (
        <div>
            <InputMobile 
                placeholder='Введите текст'
                block={true} 
                label='Текст' 
                size='s' 
                labelView='outer' 
            />
            <Gap size='l' />
            <InputMobile 
                placeholder='Введите email'
                block={true} 
                label='Email' 
                size='s' 
                labelView='outer' 
            />
        </div>
    );
});
```

## Валидация

См. гайд [валидация](?path=/docs/guidelines-validation--docs).

```jsx live
render(() => {
    const [error, setError] = React.useState(false);

    return (
        <div style={{ width: 320 }}>
            <div style={{ height: 80 }}>
                <InputDesktop block={true} label='Label' placeholder='Placeholder' size='m' error={error} />
            </div>
            <Gap size='xl' />
            <ButtonDesktop size='xxs' view='secondary' onClick={() => setError(false)}>
                По умолчанию
            </ButtonDesktop>
            <Gap size='s' direction='horizontal' />
            <ButtonDesktop size='xxs' view='secondary' onClick={() => setError('Error message')}>
                Состояние ошибки
            </ButtonDesktop>
        </div>
    );
});
//MOBILE
render(() => {
    const [error, setError] = React.useState(false);

    return (
        <div>
            <div style={{ height: 96 }}>
                <InputMobile 
                    block={true} 
                    label='Label' 
                    placeholder='Placeholder' 
                    size='s' 
                    labelView='outer' 
                    error={error} />
            </div>
            <Gap size='xl' />
            <ButtonMobile size='xxs' view='secondary' onClick={() => setError(false)}>
                По умолчанию
            </ButtonMobile>
            <Gap size='s' direction='horizontal' />
            <ButtonMobile size='xxs' view='secondary' onClick={() => setError('Error message')}>
                Состояние ошибки
            </ButtonMobile>
        </div>
    );
});
```

## Disabled и ReadOnly

Доступный только для чтения инпут может быть выбран с клавиатуры, его значение передается при отправке формы.
Заблокированный инпут нельзя выбрать с клавиатуры и его значение не будет отправлено.

```jsx live
render(() => {
    const [inputProps, setInputProps] = React.useState({});

    return (
        <div>
            <div style={{ width: 320 }}>
                <InputDesktop block={true} placeholder='Placeholder' label='Label' size='m' {...inputProps} />
            </div>
            <Gap size='xl' />

            <Space direction='horizontal' wrap={true}>
                <ButtonDesktop size='xxs' view='secondary' onClick={() => setInputProps({})}>
                    По умолчанию
                </ButtonDesktop>
                <ButtonDesktop
                    size='xxs'
                    view='secondary'
                    onClick={() => setInputProps({ disabled: true })}
                >
                    Заблокирован
                </ButtonDesktop>
                <ButtonDesktop
                    size='xxs'
                    view='secondary'
                    onClick={() => setInputProps({ readOnly: true })}
                >
                    Только чтение
                </ButtonDesktop>
            </Space>
        </div>
    );
});
//MOBILE
render(() => {
    const [inputProps, setInputProps] = React.useState({});

    return (
        <div>
            <InputMobile 
                block={true} 
                placeholder='Placeholder' 
                labelView='outer' 
                label='Label' 
                size='s' 
                {...inputProps} 
            />
            <Gap size='xl' />
            <Space direction='horizontal' wrap={true}>
                <ButtonMobile size='xxs' view='secondary' onClick={() => setInputProps({})}>
                    По умолчанию
                </ButtonMobile>
                <ButtonMobile
                    size='xxs'
                    view='secondary'
                    onClick={() => setInputProps({ disabled: true })}
                >
                    Заблокирован
                </ButtonMobile>
                <ButtonMobile
                    size='xxs'
                    view='secondary'
                    onClick={() => setInputProps({ readOnly: true })}
                >
                    Только чтение
                </ButtonMobile>
            </Space>
        </div>
    );
});
```

## Дополнительная информация

Для упрощения пользовательского ввода используется несколько паттернов вывода дополнительной информации.

1. Placeholder — подсказка внутри поля, отображается до тех пор, пока пользователь не начнет вводить значение.
2. Hint — подсказка под полем. Если поле перейдёт в состоянии ошибки hint будет заменен на сообщение об ошибке.
3. Tooltip — иконка с подсказкой.

```jsx live
render(() => {
    const [open, setOpen] = React.useState(false);

    /* Указать для IconButton через className */
    const css = `
        button[data-test-id='icon'] {
            margin-right: var(--gap-s-neg);
        }
    `;

    return (
        <div style={{ width: 320 }}>
            <style>{css}</style>
            <InputDesktop
                block={true}
                label='Инпут с плейсхолдером'
                placeholder='Placeholder'
                size='m'
                hint='Подсказка под полем'
                rightAddons={
                    <TooltipDesktop
                        open={open}
                        targetClassName='target'
                        content={
                            <span
                                style={{ whiteSpace: 'pre-wrap' }}
                            >{`Сообщение тултипа\nотображается при\nнаведении`}</span>
                        }
                        onOpen={() => setOpen(true)}
                        onClose={() => setOpen(false)}
                        position='right'
                    >
                        <IconButton
                            view='secondary'
                            size='s'
                            icon={InformationCircleMIcon}
                            dataTestId='icon'
                        />
                    </TooltipDesktop>
                }
            />
        </div>
    );
});
//MOBILE
render(() => {
    const [open, setOpen] = React.useState(false);

    /* Указать для IconButton через className */
    const css = `
        button[data-test-id='icon'] {
            margin-right: var(--gap-s-neg);
        }
    `;

    return (
        <div>
            <style>{css}</style>
            <InputMobile
                block={true}
                placeholder='Инпут с плейсхолдером'
                size='s'
                hint='Подсказка под полем'
                rightAddons={
                    <TooltipMobile
                        open={open}
                        targetClassName='target'
                        content={'Сообщение тултипа отображается при клике'}
                        onOpen={() => setOpen(true)}
                        onClose={() => setOpen(false)}
                    >
                        <IconButton
                            view='secondary'
                            size='s'
                            icon={InformationCircleMIcon}
                            dataTestId='icon'
                        />
                    </TooltipMobile>
                }
            />
        </div>
    );
});
```

## Статусы

В некоторых кейсах может потребоваться дополнительная индикация ошибки или успеха.

```jsx live
render(() => {
    const [success, setSuccess] = React.useState(false);
    const [value, setValue] = React.useState('');

    /* Не показываем вторую иконку ошибки в теме сайта */
    const css = `
        :root {
            --input-error-icon-display: none;
            --input-error-icon-not-alone-display: none;
        }
    `;

    const handleChange = (e) => {
        const value = e.target.value;
        setValue(value);

        if (value.length === 5) {
            setSuccess(true);
        } else {
            setSuccess(false);
        }
    };

    const hasError = value !== '' && !success;

    return (
        <div style={{ width: 320 }}>
            <style>{css}</style>
            <InputDesktop
                value={value}
                block={true}
                onChange={handleChange}
                label='Введите 5 символов'
                placeholder='Placeholder'
                size='m'
                success={success}
                error={hasError}
                rightAddons={
                    hasError ? (
                        <Badge
                            view='icon'
                            size='m'
                            iconColor='negative'
                            content={
                                <ExclamationCircleMIcon
                                    style={{ color: 'var(--color-light-graphic-negative)' }}
                                />
                            }
                        />
                    ) : undefined
                }
            />
        </div>
    );
});
//MOBILE
render(() => {
    const [success, setSuccess] = React.useState(false);
    const [value, setValue] = React.useState('');

    /* Не показываем вторую иконку ошибки в теме сайта */
    const css = `
        :root {
            --input-error-icon-display: none;
            --input-error-icon-not-alone-display: none;
        }
    `;

    const handleChange = (e) => {
        const value = e.target.value;
        setValue(value);

        if (value.length === 5) {
            setSuccess(true);
        } else {
            setSuccess(false);
        }
    };

    const hasError = value !== '' && !success;

    return (
        <div>
            <style>{css}</style>
            <InputMobile
                value={value}
                block={true}
                onChange={handleChange}
                label='Введите 5 символов'
                placeholder='Placeholder'
                labelView='outer'
                size='s'
                success={success}
                error={hasError}
                rightAddons={
                    hasError ? (
                        <Badge
                            view='icon'
                            size='m'
                            iconColor='negative'
                            content={
                                <ExclamationCircleMIcon
                                    style={{ color: 'var(--color-light-graphic-negative)' }}
                                />
                            }
                        />
                    ) : undefined
                }
            />
        </div>
    );
});
```

## Крестик очистки

В редких кейсах может потребоваться механика быстрой очистки введенного контента.
Рекомендуется использовать данную механику точечно, а не глобально ко всем полям большой формы.

```jsx live
render(() => {
    const [value, setValue] = React.useState('Value');

    return (
        <div style={{ width: 320 }}>
            <InputDesktop
                value={value}
                block={true}
                onChange={(e) => setValue(e.target.value)}
                label='Label'
                placeholder='Placeholder'
                size='m'
                clear={true}
                onClear={() => setValue('')}
            />
        </div>
    );
});
//MOBILE
render(() => {
    const [value, setValue] = React.useState('Value');

    return (
        <InputMobile
            value={value}
            block={true}
            onChange={(e) => setValue(e.target.value)}
            label='Label'
            placeholder='Placeholder'
            labelView='outer'
            size='s'
            clear={true}
            onClear={() => setValue('')}
        />
    );
});
```

## Кликабельные аддоны

Для кликабельных адоннов рекомендуем использовать увеличенную область нажатия.

```jsx live
render(() => {
    const [isVisible, setIsVisible] = React.useState(false);
    const [title, setTitle] = React.useState('');
    const [valueOne, setValueOne] = React.useState('Value');
    const [valueTwo, setValueTwo] = React.useState('Value');

    const toggleVisiblity = () => setIsVisible((prev) => !prev);

    const singleIcon = () => {
        setTitle('Вы восхитительны!');
        toggleVisiblity();
    };

    const leftIcon = () => {
        setTitle('Левая');
        toggleVisiblity();
    };

    const rightIcon = () => {
        setTitle('Правая');
        toggleVisiblity();
    };

    const hideNotification = React.useCallback(() => setIsVisible(false), []);

    const styleWrapperIcons = {
        height: '100%',
        display: 'flex',
        gap: 4,
        marginRight: 'var(--gap-xs-neg)',
    };

    /* Указать для IconButton через className */
    const css = `
        button[data-test-id='icon'] {
            margin-right: var(--gap-s-neg);
        }
    `;

    return (
        <div style={{ width: 320 }}>
            <style>{css}</style>
            <InputDesktop
                value={valueOne}
                block={true}
                onChange={(e) => setValueOne(e.target.value)}
                label='Label'
                placeholder='Placeholder'
                size='m'
                rightAddons={
                    <IconButton
                        view='secondary'
                        onClick={singleIcon}
                        icon={DiamondsMIcon}
                        size='s'
                        dataTestId='icon'
                    />
                }
            />
            <Gap size='l' />
            <InputDesktop
                value={valueTwo}
                block={true}
                onChange={(e) => setValueTwo(e.target.value)}
                label='Label'
                placeholder='Placeholder'
                size='m'
                rightAddons={
                    <div style={styleWrapperIcons}>
                        <IconButton
                            view='secondary'
                            onClick={leftIcon}
                            icon={DiamondsMIcon}
                            size='xs'
                            alignIcon='right'
                        />
                        <IconButton
                            view='secondary'
                            onClick={rightIcon}
                            icon={FlowerMIcon}
                            size='xs'
                            alignIcon='left'
                        />
                    </div>
                }
            />
            <ToastDesktop
                title={title}
                open={isVisible}
                onClose={hideNotification}
                hasCloser={false}
                autoCloseDelay={2000}
                style={{ left: '41%' }}
            />
        </div>
    );
});
//MOBILE
render(() => {
    const [isVisible, setIsVisible] = React.useState(false);
    const [title, setTitle] = React.useState('');
    const [valueOne, setValueOne] = React.useState('Value');
    const [valueTwo, setValueTwo] = React.useState('Value');

    const toggleVisiblity = () => setIsVisible((prev) => !prev);

    const singleIcon = () => {
        setTitle('Вы восхитительны!');
        toggleVisiblity();
    };

    const leftIcon = () => {
        setTitle('Левая');
        toggleVisiblity();
    };

    const rightIcon = () => {
        setTitle('Правая');
        toggleVisiblity();
    };

    const hideNotification = React.useCallback(() => setIsVisible(false), []);

    const styleWrapperIcons = {
        height: '100%',
        display: 'flex',
        gap: 4,
        marginRight: 'var(--gap-xs-neg)',
    };

    /* Указать для IconButton через className */
    const css = `
        button[data-test-id='icon'] {
            margin-right: var(--gap-s-neg);
        }
    `;

    return (
        <div>
            <style>{css}</style>
            <InputMobile
                value={valueOne}
                block={true}
                onChange={(e) => setValueOne(e.target.value)}
                label='Label'
                placeholder='Placeholder'
                labelView='outer'
                size='s'
                rightAddons={
                    <IconButton
                        view='secondary'
                        onClick={singleIcon}
                        icon={DiamondsMIcon}
                        size='s'
                        dataTestId='icon'
                    />
                }
            />
            <Gap size='l' />
            <InputMobile
                value={valueTwo}
                block={true}
                onChange={(e) => setValueTwo(e.target.value)}
                label='Label'
                placeholder='Placeholder'
                size='s'
                labelView='outer'
                rightAddons={
                    <div style={styleWrapperIcons}>
                        <IconButton
                            view='secondary'
                            onClick={leftIcon}
                            icon={DiamondsMIcon}
                            size='xs'
                            alignIcon='right'
                        />
                        <IconButton
                            view='secondary'
                            onClick={rightIcon}
                            icon={FlowerMIcon}
                            size='xs'
                            alignIcon='left'
                        />
                    </div>
                }
            />
            <ToastMobile
                title={title}
                open={isVisible}
                onClose={hideNotification}
                hasCloser={false}
                autoCloseDelay={2000}
                style={{ left: '30%' }}
            />
        </div>
    );
});
```

## Морфология

Компонент является оберткой над [FormControl](?path=/docs/formcontrol--docs), поэтому наследует все доступные для него настройки.
